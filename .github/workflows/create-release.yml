name: Create Draft Release

on:
  pull_request:
    types: [closed]

jobs:
  create-draft-release:
    if: github.event.pull_request.merged == true && (contains(github.event.pull_request.labels.*.name, 'major') || contains(github.event.pull_request.labels.*.name, 'minor') || contains(github.event.pull_request.labels.*.name, 'patch'))
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: main
        fetch-depth: 0

    - name: Get current version
      id: get_version
      run: |
        LATEST_TAG=$(git tag --sort=-version:refname | head -n1 2>/dev/null || echo "v0.0.0")
        echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
        
        VERSION=$(echo $LATEST_TAG | sed 's/v//')
        echo "current_version=$VERSION" >> $GITHUB_OUTPUT
        
        echo "Debug: Latest tag found: $LATEST_TAG"
        echo "Debug: Current version: $VERSION"

    - name: Calculate new version
      id: calculate_version
      run: |
        CURRENT_VERSION="${{ steps.get_version.outputs.current_version }}"
        
        if [[ -z "$CURRENT_VERSION" ]] || [[ "$CURRENT_VERSION" == "0.0.0" ]]; then
          MAJOR=0
          MINOR=0
          PATCH=0
        else
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
        fi
        
        LABELS="${{ join(github.event.pull_request.labels.*.name, ' ') }}"
        
        if [[ "$LABELS" == *"major"* ]]; then
          NEW_MAJOR=$((MAJOR + 1))
          NEW_MINOR=0
          NEW_PATCH=0
          VERSION_TYPE="major"
        elif [[ "$LABELS" == *"minor"* ]]; then
          NEW_MAJOR=$MAJOR
          NEW_MINOR=$((MINOR + 1))
          NEW_PATCH=0
          VERSION_TYPE="minor"
        elif [[ "$LABELS" == *"patch"* ]]; then
          NEW_MAJOR=$MAJOR
          NEW_MINOR=$MINOR
          NEW_PATCH=$((PATCH + 1))
          VERSION_TYPE="patch"
        else
          echo "No version label found in: $LABELS"
          exit 1
        fi
        
        NEW_VERSION="${NEW_MAJOR}.${NEW_MINOR}.${NEW_PATCH}"
        NEW_TAG="v${NEW_VERSION}"
        
        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT
        echo "version_type=$VERSION_TYPE" >> $GITHUB_OUTPUT
        
        echo "Debug: Current version parts - MAJOR:$MAJOR MINOR:$MINOR PATCH:$PATCH"
        echo "Debug: New version parts - MAJOR:$NEW_MAJOR MINOR:$NEW_MINOR PATCH:$NEW_PATCH"
        echo "Debug: Labels found: $LABELS"
        echo "Debug: Version type: $VERSION_TYPE"

    - name: Get release notes from latest public release
      id: get_release_notes
      run: |
        LATEST_TAG="${{ steps.get_version.outputs.latest_tag }}"
        NEW_TAG="${{ steps.calculate_version.outputs.new_tag }}"
        
        echo "=== DEBUG: Release Notes Generation ==="
        echo "Latest tag: $LATEST_TAG"
        echo "New tag: $NEW_TAG"
        
        if [[ "$LATEST_TAG" == "v0.0.0" ]]; then
          echo "First release detected - getting all PRs merged to main"
          RELEASE_NOTES=$(gh pr list --state merged --base main --json title --jq '.[].title' | sed 's/^/- /')
          echo "Found PRs for first release:"
          echo "$RELEASE_NOTES"
        else
          echo "Getting latest public release notes for tag: $LATEST_TAG"
          LATEST_RELEASE_NOTES=$(gh release view "$LATEST_TAG" --json body --jq '.body' 2>/dev/null || echo "")
          
          if [[ -n "$LATEST_RELEASE_NOTES" ]]; then
            echo "Successfully retrieved release notes from $LATEST_TAG"
            echo "Release notes length: ${#LATEST_RELEASE_NOTES} characters"
            echo "Extracting 'Merged PRs since last release' section..."
            
            # Extract the "Merged PRs since last release" section
            RELEASE_NOTES=$(echo "$LATEST_RELEASE_NOTES" | sed -n '/### Merged PRs since last release:/,/### Next Steps:/p' | sed '1d;$d' | sed 's/^/- /')
            echo "Extracted section:"
            echo "$RELEASE_NOTES"
          else
            echo "No release notes found for $LATEST_TAG, falling back to PR list"
            echo "Getting PRs merged since: $(git log -1 --format=%ai "$LATEST_TAG")"
            
            # Fallback to getting PRs merged since last tag
            RELEASE_NOTES=$(gh pr list --state merged --base main --json title,mergedAt --jq '.[] | select(.mergedAt > "'$(git log -1 --format=%ai "$LATEST_TAG")'") | .title' | sed 's/^/- /')
            echo "Found PRs since last tag:"
            echo "$RELEASE_NOTES"
          fi
        fi
        
        if [[ -z "$RELEASE_NOTES" ]]; then
          echo "No changes found, using default message"
          RELEASE_NOTES="- No changes found since last release"
        fi
        
        echo "Final release notes:"
        echo "$RELEASE_NOTES"
        echo "=== End DEBUG ==="
        
        echo "release_notes<<EOF" >> $GITHUB_OUTPUT
        echo "$RELEASE_NOTES" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Create Draft Release
      run: |
        gh release create ${{ steps.calculate_version.outputs.new_tag }} \
          --title "Release ${{ steps.calculate_version.outputs.new_tag }}" \
          --notes "## Changes
        
        This is a draft release for version ${{ steps.calculate_version.outputs.new_tag }}
        
        ### Version Type: ${{ steps.calculate_version.outputs.version_type }}
        
        - Previous version: ${{ steps.get_version.outputs.latest_tag }}
        - New version: ${{ steps.calculate_version.outputs.new_tag }}
        
        ### Changes since last release:
        ${{ steps.get_release_notes.outputs.release_notes }}
        
        ### Next Steps
        1. Review the changes
        2. Publish this release to trigger image build
        3. Deploy to dev/prod with the new image tag" \
          --draft
      env:
        GITHUB_TOKEN: ${{ secrets.RELEASE_TOKEN }}
