name: Create Draft Release

on:
  pull_request:
    types: [closed]

jobs:
  create-draft-release:
    if: >
      github.event.pull_request.merged == true &&
      (contains(github.event.pull_request.labels.*.name, 'major') ||
       contains(github.event.pull_request.labels.*.name, 'minor') ||
       contains(github.event.pull_request.labels.*.name, 'patch'))
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Get latest published release version
        id: get_version
        env:
          GH_TOKEN: ${{ secrets.RELEASE_TOKEN }}
        run: |
          set -e
          echo "Fetching latest published release tag..."

          LATEST_PUBLISHED_TAG=$(gh release list --json tagName,isDraft,createdAt \
            --jq '[.[] | select(.isDraft == false)] | sort_by(.createdAt) | reverse | .[0].tagName' 2>/dev/null | tr -d '"' || echo "v0.0.0")

          if [[ -z "$LATEST_PUBLISHED_TAG" ]]; then
            LATEST_PUBLISHED_TAG="v0.0.0"
          fi

          echo "latest_published_tag=$LATEST_PUBLISHED_TAG" >> "$GITHUB_OUTPUT"

          VERSION=$(echo "$LATEST_PUBLISHED_TAG" | sed 's/^v//;s/[^0-9.].*$//')
          echo "current_version=$VERSION" >> "$GITHUB_OUTPUT"

          echo "Latest published tag: $LATEST_PUBLISHED_TAG"
          echo "Parsed current version: $VERSION"

      - name: Calculate new version
        id: calculate_version
        env:
          LABELS: ${{ join(github.event.pull_request.labels.*.name, ' ') }}
        run: |
          set -e
          CURRENT_VERSION="${{ steps.get_version.outputs.current_version }}"

          IFS='.' read -r MAJOR MINOR PATCH <<< "${CURRENT_VERSION:-0.0.0}"
          PATCH=${PATCH:-0}

          if [[ "$LABELS" == *"major"* ]]; then
            NEW_MAJOR=$((MAJOR + 1)); NEW_MINOR=0; NEW_PATCH=0; VERSION_TYPE="major"
          elif [[ "$LABELS" == *"minor"* ]]; then
            NEW_MAJOR=$MAJOR; NEW_MINOR=$((MINOR + 1)); NEW_PATCH=0; VERSION_TYPE="minor"
          elif [[ "$LABELS" == *"patch"* ]]; then
            NEW_MAJOR=$MAJOR; NEW_MINOR=$MINOR; NEW_PATCH=$((PATCH + 1)); VERSION_TYPE="patch"
          else
            echo "No version label found."
            exit 1
          fi

          NEW_VERSION="${NEW_MAJOR}.${NEW_MINOR}.${NEW_PATCH}"
          NEW_TAG="v${NEW_VERSION}"

          echo "new_version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
          echo "new_tag=$NEW_TAG" >> "$GITHUB_OUTPUT"
          echo "version_type=$VERSION_TYPE" >> "$GITHUB_OUTPUT"

      - name: Get release notes from commits since last published release
        id: get_release_notes
        env:
          GH_TOKEN: ${{ secrets.RELEASE_TOKEN }}
        run: |
          set -e
          LATEST_PUBLISHED_TAG="${{ steps.get_version.outputs.latest_published_tag }}"
          NEW_TAG="${{ steps.calculate_version.outputs.new_tag }}"

          echo "Getting commits since last published release: $LATEST_PUBLISHED_TAG"

          if [[ "$LATEST_PUBLISHED_TAG" == "v0.0.0" ]]; then
            # First release - get all PRs merged to main
            echo "First release - getting all PRs merged to main"
            RELEASE_NOTES=$(gh pr list --state merged --base main --json title --jq '.[].title' | sed 's/^/- /')
          else
            # Get the commit hash of the last published release
            LAST_RELEASE_COMMIT=$(git rev-parse "$LATEST_PUBLISHED_TAG" 2>/dev/null || echo "")
            
            if [[ -n "$LAST_RELEASE_COMMIT" ]]; then
              echo "Last published release commit: $LAST_RELEASE_COMMIT"
              
              # Get all commits since the last published release
              COMMITS_SINCE=$(git log --oneline --pretty=format:"%H %s" "$LAST_RELEASE_COMMIT..HEAD")
              echo "Commits since last release:"
              echo "$COMMITS_SINCE"
              
              # Get PR titles for these commits
              RELEASE_NOTES=""
              while IFS= read -r line; do
                if [[ -n "$line" ]]; then
                  COMMIT_HASH=$(echo "$line" | cut -d' ' -f1)
                  COMMIT_MSG=$(echo "$line" | cut -d' ' -f2-)
                  
                  # Clean up commit message - remove "Merge pull request" part
                  CLEAN_MSG=$(echo "$COMMIT_MSG" | sed 's/^Merge pull request #[0-9]\+ from [^[:space:]]\+ - //')
                  
                  # Try to find PR number in commit message (conventional commits often have (#123))
                  PR_NUMBER=$(echo "$COMMIT_MSG" | grep -o '(#[0-9]\+)' | grep -o '[0-9]\+' || echo "")
                  
                  if [[ -n "$PR_NUMBER" ]]; then
                    # Get PR title from PR number
                    PR_TITLE=$(gh pr view "$PR_NUMBER" --json title --jq '.title' 2>/dev/null || echo "")
                    if [[ -n "$PR_TITLE" ]]; then
                      RELEASE_NOTES="$RELEASE_NOTES - $PR_TITLE"
                    else
                      # Use cleaned commit message as fallback
                      RELEASE_NOTES="$RELEASE_NOTES - $CLEAN_MSG"
                    fi
                  else
                    # Use cleaned commit message as fallback
                    RELEASE_NOTES="$RELEASE_NOTES - $CLEAN_MSG"
                  fi
                fi
              done <<< "$COMMITS_SINCE"
            else
              echo "Could not find commit for tag $LATEST_PUBLISHED_TAG, using current PR only"
              RELEASE_NOTES="- ${{ github.event.pull_request.title }}"
            fi
          fi

          # Clean up the release notes (remove leading newlines)
          RELEASE_NOTES=$(echo "$RELEASE_NOTES" | sed '/^$/d' | sed '1s/^[[:space:]]*//')

          if [[ -z "$RELEASE_NOTES" ]]; then
            RELEASE_NOTES="- ${{ github.event.pull_request.title }}"
          fi

          echo "Final release notes:"
          echo "$RELEASE_NOTES"

          {
            echo "release_notes<<EOF"
            echo "$RELEASE_NOTES"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Ensure tag doesn't already exist
        run: |
          set -e
          NEW_TAG="${{ steps.calculate_version.outputs.new_tag }}"
          if git rev-parse "$NEW_TAG" >/dev/null 2>&1; then
            git push origin ":refs/tags/$NEW_TAG"
          fi

      - name: Create Draft Release
        env:
          GH_TOKEN: ${{ secrets.RELEASE_TOKEN }}
        run: |
          set -e
          NEW_TAG="${{ steps.calculate_version.outputs.new_tag }}"
          VERSION_TYPE="${{ steps.calculate_version.outputs.version_type }}"
          LATEST_TAG="${{ steps.get_version.outputs.latest_published_tag }}"
          NOTES="${{ steps.get_release_notes.outputs.release_notes }}"

          gh release create "$NEW_TAG" \
            --title "Release $NEW_TAG" \
            --notes "## Auto-generated draft release
                    **Version Type:** $VERSION_TYPE  
                    **Previous Release:** $LATEST_TAG  
                    **New Tag:** $NEW_TAG  

                    ### Changes:
                    $NOTES

                    ---

                    ### Next Steps
                    1. **Publish this release** to trigger *Build and Push API Image*
                    2. Wait for build to complete
                    3. **Run 'Deploy to Environment'** with tag: $NEW_TAG

                    _Auto-generated draft release by workflow_" \
                                --draft

    outputs:
      new_tag: ${{ steps.calculate_version.outputs.new_tag }}
      version_type: ${{ steps.calculate_version.outputs.version_type }}
